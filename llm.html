<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>累了吗 · 转一转</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            background-color: #1a1a1a;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none; /* 禁止页面滚动/缩放 */
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background: #1a1a1a; /* 深色背景，保护眼睛 */
        }
        /* 极简角落入口（不打扰，但存在） */
        .corner {
            position: fixed;
            bottom: 20px;
            right: 20px;
            font-size: 13px;
            color: #333;
            background: rgba(30,30,30,0.8);
            padding: 8px 16px;
            border-radius: 40px;
            backdrop-filter: blur(4px);
            border: 0.5px solid #2a2a2a;
            letter-spacing: 0.5px;
            z-index: 10;
        }
        .corner a {
            color: #666;
            text-decoration: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="corner"><a href="#" id="coffeeLink">▪</a></div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // 物理参数
        const radius = 30;               // 小圆半径
        const friction = 0.98;            // 摩擦力（每帧速度衰减）
        const bounce = 0.6;               // 边界反弹系数（0~1）
        const touchFactor = 0.2;           // 拖拽时目标位置的影响因子（越小越顺滑）

        let pos = { x: 200, y: 200 };      // 当前位置
        let v = { x: 0, y: 0 };            // 当前速度
        let dragging = false;
        let targetPos = { x: 200, y: 200 }; // 拖拽时的目标位置

        // 初始化画布尺寸
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // 如果初始位置超出边界，拉回来
            pos.x = Math.min(Math.max(pos.x, radius), canvas.width - radius);
            pos.y = Math.min(Math.max(pos.y, radius), canvas.height - radius);
            targetPos.x = pos.x;
            targetPos.y = pos.y;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // 触摸事件处理
        function handleStart(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const canvasX = (clientX - rect.left) * scaleX;
            const canvasY = (clientY - rect.top) * scaleY;

            // 检查是否点中圆（增加点击区域，方便触摸）
            const dx = canvasX - pos.x;
            const dy = canvasY - pos.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < radius * 1.5) {  // 1.5倍半径，更容易抓住
                dragging = true;
                targetPos.x = canvasX;
                targetPos.y = canvasY;
                v.x = 0;
                v.y = 0;
            }
        }

        function handleMove(e) {
            if (!dragging) return;
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const canvasX = (clientX - rect.left) * scaleX;
            const canvasY = (clientY - rect.top) * scaleY;

            // 更新目标位置
            targetPos.x = canvasX;
            targetPos.y = canvasY;
        }

        function handleEnd(e) {
            if (dragging) {
                dragging = false;
                // 释放时给一个小的初速度，模拟惯性（基于移动速度）
                // 这里简单起见，不计算移动速度，让物理自然衰减即可
            }
            e.preventDefault();
        }

        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('touchcancel', handleEnd);
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseleave', handleEnd); // 鼠标离开画布视为释放

        // 物理更新
        function update() {
            if (dragging) {
                // 拖拽时，位置向目标点平滑移动（带一点弹性）
                const dx = targetPos.x - pos.x;
                const dy = targetPos.y - pos.y;
                // 加入惯性效果：距离越远，速度越快
                v.x += dx * touchFactor;
                v.y += dy * touchFactor;
                // 限制最大速度，避免太飘
                const maxSpeed = 15;
                const speed = Math.sqrt(v.x*v.x + v.y*v.y);
                if (speed > maxSpeed) {
                    v.x = (v.x / speed) * maxSpeed;
                    v.y = (v.y / speed) * maxSpeed;
                }
            }

            // 应用摩擦力
            v.x *= friction;
            v.y *= friction;

            // 更新位置
            pos.x += v.x;
            pos.y += v.y;

            // 边界碰撞处理
            if (pos.x < radius) {
                pos.x = radius;
                v.x = -v.x * bounce;
            } else if (pos.x > canvas.width - radius) {
                pos.x = canvas.width - radius;
                v.x = -v.x * bounce;
            }
            if (pos.y < radius) {
                pos.y = radius;
                v.y = -v.y * bounce;
            } else if (pos.y > canvas.height - radius) {
                pos.y = canvas.height - radius;
                v.y = -v.y * bounce;
            }

            // 如果速度极小，就完全停止（避免微动）
            if (Math.abs(v.x) < 0.01 && Math.abs(v.y) < 0.01 && !dragging) {
                v.x = 0;
                v.y = 0;
            }
        }

        // 绘制
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 画小圆（带一点光晕）
            ctx.shadowColor = '#ffb34766';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
            ctx.fillStyle = '#ffb347';
            ctx.fill();

            // 画一个小高光
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.arc(pos.x - 6, pos.y - 6, 8, 0, Math.PI * 2);
            ctx.fillStyle = '#ffffff30';
            ctx.fill();

            // 如果拖拽中，显示一个淡淡的拖拽指示（可选）
            if (dragging) {
                ctx.beginPath();
                ctx.arc(targetPos.x, targetPos.y, radius * 0.8, 0, Math.PI * 2);
                ctx.strokeStyle = '#ffffff40';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        // 动画循环
        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }
        loop();

        // 咖啡链接（无打扰）
        document.getElementById('coffeeLink').addEventListener('click', (e) => {
            e.preventDefault();
            alert('感谢你有这个心。继续转吧，别想太多。');
        });
    </script>
</body>
</html>